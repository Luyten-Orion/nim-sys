#
#            Abstractions for operating system services
#                   Copyright (c) 2021 Leorize
#
# Licensed under the terms of the MIT license which can be found in
# the file "license.txt" included with this distribution. Alternatively,
# the full text can be found at: https://spdx.org/licenses/MIT.html

import std/strformat
import syscall/winim/winim/core as wincore except Handle
import errors

const
  BufferSize = 0
    ## Pipe buffer size. `0` means Windows' default.

template makePipe(p, inheritable, initFileProc: untyped) =
  var sa: SecurityAttributes
  sa.nLength = sizeof(sa)
  sa.bInheritHandle = WinBool inheritable

  var rd, wr: wincore.Handle
  if not CreatePipe(addr rd, addr wr, addr sa, BufferSize):
    raise newOSError(GetLastError(), ErrorPipeCreation)

  p.rd = initFileProc(rd)
  p.wr = initFileProc(wr)

template initPipeImpl() {.dirty.} =
  makePipe(result, ffInheritable in flags, initFile)

template newPipeImpl() {.dirty.} =
  makePipe(result, ffInheritable in flags, newFile)

# TODO: when sys/random inevitably come to live, move this there
proc secureRandomUint(): BiggestUInt =
  ## Generate a random number of the biggest uint type using the operating
  ## system cryptographic random number engine.
  let status = BCryptGenRandom(nil, cast[PUChar](addr result),
                               ULong sizeof(result),
                               BCryptUseSystemPreferredRng)
  if status != StatusSuccess:
    raise newOSError(RtlNtStatusToDosError(status), "Could not produce random numbers")

const
  NamedPipePrefix = r"\\.\pipe\nim-sys"
    ## The prefix used for anon pipes generated by this module.

proc generateUniquePipeName(): string =
  ## Generate a completely unique name for a pipe.
  result = fmt"{NamedPipePrefix}.{getCurrentProcessID()}.{secureRandomUint()}"

template makeAsyncPipe(p, inheritable, initFileProc: untyped) =
  var sa: SecurityAttributes
  sa.nLength = sizeof(sa)
  sa.bInheritHandle = WinBool inheritable

  let
    pipeName = generateUniquePipeName()
    rd = CreateNamedPipeA(
      pipeName,
      dwOpenMode = PipeAccessInbound or
        FileFlagFirstPipeInstance or
        FileFlagOverlapped,
      dwPipeMode = PipeTypeByte or
        PipeWait or
        PipeRejectRemoteClients,
      nMaxInstances = 1,
      nOutBufferSize = BufferSize,
      nInBufferSize = BufferSize,
      nDefaultTimeout = 0,
      addr sa
    )

  if rd == InvalidHandleValue:
    raise newOSError(GetLastError(), ErrorPipeCreation)

  let wr = CreateFileA(pipeName, GenericWrite, dwShareMode = 0, addr sa,
                       FileFlagOverlapped, nil)

  if wr == InvalidHandleValue:
    raise newOSError(GetLastError(), ErrorPipeCreation)

  p.rd = initFileProc(FD rd)
  p.wr = initFileProc(FD wr)

template initAsyncPipeImpl() {.dirty.} =
  makeAsyncPipe(result, ffInheritable in flags, initAsyncFile)

template newAsyncPipeImpl() {.dirty.} =
  makeAsyncPipe(result, ffInheritable in flags, newAsyncFile)
